{"version":3,"sources":["app/a_star.js","app/balls_generator.js","app/color.js","app/game.js","app/geo.js","app/interaction.js","app/map_drawer.js","app/regions_gatherer.js","app/rivers_and_lakes_generator.js","app/rrt_diagram.js","app/texture_generator.js","app/util.js","app/voronoi_diagram.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnJA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnGA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApIA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxQA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvLA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9hBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvLA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5HA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlTA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/EA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApOA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlMA;AAAA","file":"public/app.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  @param function getNeighboursFunc(point) -> [{point: neighbourPoint, weight: integer() | float()}]\n *    return list of all neighbours points with weight to move from given point to it\n *  @param function euristicFunc(pointFrom, pointTo) -> integer() | float()\n *    return estimated distance between two points\n *    for square map its a\n *    Math.abs(pointFrom.location.x - pointTo.location.x) + Math.abs(pointFrom.location.y - pointTo.location.y)\n *    for graphs without any coords representation its a very complicated task, suppose return just 0 (zero)\n *  @param int|float euristicWeight -- euristic distance weight multiplier\n *    you can set it to standard weight of one vertical|horisontal move\n */\nvar AStar = function () {\n  function AStar(getNeighboursFunc) {\n    var euristicFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var euristicWeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var pointIndexFunc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, AStar);\n\n    this.getNeighboursFunc = getNeighboursFunc;\n    this.euristicFunc = euristicFunc ? euristicFunc : AStar.standardEuristic;\n    this.euristicWeight = euristicWeight;\n    this.pointIndexFunc = pointIndexFunc;\n  }\n\n  _createClass(AStar, [{\n    key: 'find',\n    value: function find(startPoint, finishPoint) {\n      var openList = {},\n          closedList = {};\n      this.addToOpenList(startPoint, 0, null, openList);\n      this.counter = 0; // TEMP\n      return this.step(openList, closedList, finishPoint);\n    }\n  }, {\n    key: 'step',\n    value: function step(openList, closedList, finishPoint) {\n      this.counter++;\n      if (this.counter > 10000) {\n        throw 'counter overflow';\n      }\n      if (this.openListIsEmpty(openList)) {\n        return false; // no way to finish\n      }\n      var pointObj = this.popPointFromOpenList(openList);\n      // TODO -- preferable way is diagonal. do it some way\n      var neighbours = this.getNeighboursFunc(pointObj.point);\n      for (var i = 0; i < neighbours.length; i++) {\n        var e = neighbours[i];\n        var weight = e.weight + pointObj.weight + this.euristicWeight * this.euristicFunc(e.point, finishPoint);\n\n        if (e.point == finishPoint) {\n          var path = [e.point, pointObj.point],\n              iPointObj = pointObj;\n          while (iPointObj.parent != null) {\n            path.push(iPointObj.parent.point);\n            iPointObj = iPointObj.parent;\n          }\n          return path;\n        } else if (this.checkPointInClosedList(e, closedList)) {\n          // just do nothing\n        } else {\n          var foundInOpenList = this.getFromOpenList(e, openList);\n          if (foundInOpenList) {\n            foundInOpenList.parent = pointObj;\n            foundInOpenList.weight = weight;\n          } else {\n            this.addToOpenList(e.point, weight, pointObj, openList);\n          }\n        }\n      }\n      this.addToClosedList(pointObj, closedList);\n      return this.step(openList, closedList, finishPoint);\n    }\n\n    // TODO -- its a hack -- we suggest some imput data structure\n    // TODO -- change the whole func to call to this.pointIndexFunc thru all code\n\n  }, {\n    key: 'listKey',\n    value: function listKey(pointObj) {\n      if (this.pointIndexFunc) {\n        return this.pointIndexFunc(pointObj.point);\n      }\n      return pointObj.point.location.x + '|' + pointObj.point.location.y;\n    }\n  }, {\n    key: 'addToOpenList',\n    value: function addToOpenList(point, pointWeight, parentPointObj, openList) {\n      var pointObj = { point: point, weight: pointWeight, parent: parentPointObj };\n      openList[this.listKey(pointObj)] = pointObj;\n    }\n  }, {\n    key: 'openListIsEmpty',\n    value: function openListIsEmpty(openList) {\n      return Object.keys(openList).length == 0;\n    }\n  }, {\n    key: 'getFromOpenList',\n    value: function getFromOpenList(pointObj, openList) {\n      return openList[this.listKey(pointObj)];\n    }\n  }, {\n    key: 'popPointFromOpenList',\n    value: function popPointFromOpenList(openList) {\n      var cur = {},\n          index = void 0;\n      for (var i in openList) {\n        if (openList[i].weight < cur.weight || !cur.weight) {\n          cur = openList[i];\n          index = i;\n        }\n      }\n      delete openList[index];\n      return cur;\n    }\n  }, {\n    key: 'addToClosedList',\n    value: function addToClosedList(pointObj, closedList) {\n      closedList[this.listKey(pointObj)] = pointObj;\n    }\n  }, {\n    key: 'checkPointInClosedList',\n    value: function checkPointInClosedList(pointObj, closedList) {\n      return closedList[this.listKey(pointObj)] != undefined;\n    }\n  }], [{\n    key: 'standardEuristic',\n    value: function standardEuristic(pointFrom, pointTo) {\n      return Math.abs(pointFrom.x - pointTo.x) + Math.abs(pointFrom.y - pointTo.y);\n    }\n  }]);\n\n  return AStar;\n}();\n\nexports.default = AStar;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _voronoi_diagram = require(\"voronoi_diagram\");\n\nvar _voronoi_diagram2 = _interopRequireDefault(_voronoi_diagram);\n\nvar _color = require(\"color\");\n\nvar _color2 = _interopRequireDefault(_color);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BallsGenerator = function () {\n  function BallsGenerator(diagram, color_map, drawer) {\n    _classCallCheck(this, BallsGenerator);\n\n    this.diagram = diagram;\n    this.color_map = color_map;\n    this.drawer = drawer;\n  }\n\n  _createClass(BallsGenerator, [{\n    key: \"generate\",\n    value: function generate() {\n      var num_balls = 0.6 * this.drawer.map.view.width * this.drawer.map.view.height | 0;\n      console.log('num_balls', num_balls);\n      var ball_radius_min = 1;\n      var ball_radius_max = 5;\n      var color_step = 5;\n      var color_count = 2;\n      var graphics = new PIXI.Graphics();\n      while (num_balls--) {\n        var rx = _util2.default.rand(1, this.drawer.map.view.width - 1);\n        var ry = _util2.default.rand(1, this.drawer.map.view.height - 1);\n        var cell = _voronoi_diagram2.default.find({ x: rx, y: ry }, this.diagram);\n        var base = this.color_map[cell.geo_type];\n        var color = _color2.default.random_near(base, color_step, color_count);\n        var radius = _util2.default.rand(ball_radius_min, ball_radius_max);\n        graphics.beginFill(_color2.default.to_pixi(color));\n        graphics.drawCircle(rx, ry, radius);\n        graphics.endFill();\n      }\n      var texture = graphics.generateCanvasTexture(PIXI.SCALE_MODES.LINEAR);\n      var sprite = new PIXI.Sprite(texture);\n      this.drawer.layers['geo'].addChild(sprite);\n    }\n  }]);\n\n  return BallsGenerator;\n}();\n\nexports.default = BallsGenerator;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Color = function () {\n  function Color() {\n    _classCallCheck(this, Color);\n  }\n\n  _createClass(Color, null, [{\n    key: \"random_near\",\n    value: function random_near(_ref) {\n      var _ref2 = _slicedToArray(_ref, 3),\n          r = _ref2[0],\n          g = _ref2[1],\n          b = _ref2[2];\n\n      var step = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n      var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n\n      return Color.for_rgb([r, g, b], function (e) {\n        return Color.random_channel(e, step, count);\n      });\n    }\n  }, {\n    key: \"random\",\n    value: function random(_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 3),\n          r = _ref4[0],\n          g = _ref4[1],\n          b = _ref4[2];\n\n      var step = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n      return Color.for_rgb([r, g, b], function (e) {\n        return Color.random_by_floor(e, step);\n      });\n    }\n  }, {\n    key: \"to_pixi\",\n    value: function to_pixi(_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 3),\n          r = _ref6[0],\n          g = _ref6[1],\n          b = _ref6[2];\n\n      return (r << 16) + (g << 8) + b;\n    }\n\n    // PRIVATE\n\n  }, {\n    key: \"for_rgb\",\n    value: function for_rgb(_ref7, func) {\n      var _ref8 = _slicedToArray(_ref7, 3),\n          r = _ref8[0],\n          g = _ref8[1],\n          b = _ref8[2];\n\n      return [func(r), func(g), func(b)];\n    }\n\n    // PRIVATE\n\n  }, {\n    key: \"random_channel\",\n    value: function random_channel(base, step, count) {\n      var rand = step * _util2.default.rand(-count, count);\n      var res = base + rand;\n      return res > 255 ? 255 : res < 0 ? 0 : res;\n    }\n\n    // PRIVATE\n\n  }, {\n    key: \"random_by_floor\",\n    value: function random_by_floor(floor, step) {\n      return floor - step * _util2.default.rand(0, floor / step | 0);\n    }\n  }]);\n\n  return Color;\n}();\n\nexports.default = Color;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _voronoi_diagram = require(\"voronoi_diagram\");\n\nvar _voronoi_diagram2 = _interopRequireDefault(_voronoi_diagram);\n\nvar _regions_gatherer = require(\"regions_gatherer\");\n\nvar _regions_gatherer2 = _interopRequireDefault(_regions_gatherer);\n\nvar _rrt_diagram = require(\"rrt_diagram\");\n\nvar _rrt_diagram2 = _interopRequireDefault(_rrt_diagram);\n\nvar _geo = require(\"geo\");\n\nvar _geo2 = _interopRequireDefault(_geo);\n\nvar _a_star = require(\"a_star\");\n\nvar _a_star2 = _interopRequireDefault(_a_star);\n\nvar _interaction = require(\"interaction\");\n\nvar _interaction2 = _interopRequireDefault(_interaction);\n\nvar _map_drawer = require(\"map_drawer\");\n\nvar _map_drawer2 = _interopRequireDefault(_map_drawer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Game = function () {\n  function Game() {\n    _classCallCheck(this, Game);\n\n    // CONST\n    this.width = 800;\n    this.height = 800;\n    this.cells_count = Infinity;\n    this.rrt_epsilon = 35;\n    this.rrt_reject_limit = 500;\n    this.map_drawer = new _map_drawer2.default(this.width, this.height);\n    this.interaction = new _interaction2.default(this);\n  }\n\n  _createClass(Game, [{\n    key: \"generate_map\",\n    value: function generate_map() {\n      var _this = this;\n\n      this.rrt = new _rrt_diagram2.default(this.width, this.height);\n      this.rrt.generate(this.rrt_epsilon, this.cells_count, this.rrt_reject_limit);\n      this.diagram = _voronoi_diagram2.default.generate(this.rrt.nodes, this.width, this.height);\n\n      // find closes point\n      this.diagram.cells.forEach(function (cell) {\n        return cell.closest_backlinks = [];\n      });\n      this.diagram.cells.forEach(function (cell) {\n        cell.closest_link = cell.links[0];\n        _util2.default.push_uniq(cell, cell.closest_link.closest_backlinks);\n      });\n\n      // find close-to-border \n      this.diagram.cells.forEach(function (cell) {\n        cell.on_border = false;\n      });\n      this.diagram.edges.forEach(function (edge) {\n        if (!edge.right) {\n          edge.on_border = true;\n          edge.from.on_border = true;\n          edge.to.on_border = true;\n          _this.diagram.cells[edge.left.index].on_border = true;\n        }\n      });\n\n      // RegionsGatherer.gather_regions(diagram);\n\n      // find ways experiment\n      /*\n      let from = Util.rand_element(diagram.cells);\n      let to = Util.rand_element(diagram.cells);\n      let get_links_fun = (cell) => cell.links.map(e => {\n        let mid_point = MapDrawer.two_cells_edge_midpoint(diagram, e, cell);\n        return {\n          point: e,\n          weight: Util.distance(e, mid_point) + Util.distance(mid_point, cell),\n        };\n      });\n      let index_fun = (cell) => cell.index;\n      let euristic_fun = (c1, c2) => Util.distance(c1, c2);\n      let euristic_weight = 1;\n      let a_star = new AStar(get_links_fun, euristic_fun, euristic_weight, index_fun);\n      let path = a_star.find(from, to);\n      */\n\n      this.map_drawer.world_init(this.diagram, this.rrt);\n      this.geo = new _geo2.default(this.diagram, this.rrt, this.map_drawer);\n      this.map_drawer.draw();\n      // map_drawer.map is a pixi.js app\n\n      this.map_drawer.highlight_bad_river_links();\n      this.map_drawer.highlight_local_minimums();\n      //this.map_drawer.highlight_bad_voronoi_nodes();\n      //this.map_drawer.print_text_for_each_cell(cell => cell.fertility);\n\n      console.log('RRT', this.rrt);\n      console.log('DIAGRAM', this.diagram);\n    }\n  }]);\n\n  return Game;\n}();\n\nexports.default = Game;\n\n\nvar game = new Game();\ngame.generate_map();\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _rrt_diagram = require(\"rrt_diagram\");\n\nvar _rrt_diagram2 = _interopRequireDefault(_rrt_diagram);\n\nvar _rivers_and_lakes_generator = require(\"rivers_and_lakes_generator\");\n\nvar _rivers_and_lakes_generator2 = _interopRequireDefault(_rivers_and_lakes_generator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Geo = function () {\n  function Geo(diagram, rrt, map_drawer) {\n    _classCallCheck(this, Geo);\n\n    this.map_drawer = map_drawer;\n    this.sea_ratio = 0.3;\n    this.rock_height_ratio = 0.75;\n    this.rrt_regions = 3;\n    this.diagram = diagram;\n    this.rrt = rrt;\n    var max_branch_order = _util2.default.find_min_and_max(this.rrt.nodes, function (node) {\n      return node.branch_order;\n    }).max;\n    console.log('WE GONNA remove_some_links_and_recalc_all', this.rrt_regions - 1);\n    var deleted_links = this.rrt.remove_some_links_and_recalc_all(this.rrt_regions - 1, max_branch_order - 10, max_branch_order - 2);\n    var centers = this.rrt.nodes.filter(function (node) {\n      return node.generation == 0;\n    });\n    console.log('rrt centers', centers);\n    this.init_height();\n    this.generate_heights_by_rrt_generations();\n    this.generate_heights_by_rrt_branches_length();\n    this.height_smooth(); // experimental\n    this.set_nodes_height_by_cell_height();\n    this.generate_sea(this.sea_ratio);\n\n    //this.map_drawer.print_text_for_each_cell(cell => cell.branch_order);\n    this.rrt.restore_removed_links(deleted_links);\n    this.map_drawer.highlight_deleted_links(deleted_links);\n\n    this.generate_rivers();\n    this.generate_rocks_by_height();\n    this.calc_fertility();\n    this.geo_types_by_fertility();\n  }\n\n  _createClass(Geo, [{\n    key: \"generate_sea\",\n    value: function generate_sea(sea_ratio) {\n      var _this = this;\n\n      var sea_cells_threshold = Math.floor(sea_ratio * this.diagram.cells.length);\n      var count_sea_cells = 0;\n\n      var _loop = function _loop(i) {\n        if (count_sea_cells >= sea_cells_threshold) {\n          return \"break\";\n        }\n        var open_list = [];\n        _this.diagram.cells.forEach(function (cell) {\n          if (cell.height <= i && cell.geo_type != 'sea') {\n            open_list.push(cell);\n          }\n        });\n        var length_before = void 0;\n        do {\n          length_before = open_list.length;\n          open_list = open_list.filter(function (cell) {\n            // we dont set sea type to inland regions, only to connected to other seas\n            if (cell.on_border || cell.links.some(function (c) {\n              return c.geo_type == 'sea';\n            })) {\n              cell.geo_type = 'sea';\n              count_sea_cells++;\n              return false;\n            }\n            return true;\n          });\n        } while (open_list.length && length_before != open_list.length);\n      };\n\n      for (var i in this.heights_stat()) {\n        var _ret = _loop(i);\n\n        if (_ret === \"break\") break;\n      }\n      // set shores\n      this.diagram.cells.forEach(function (cell) {\n        cell.shore = cell.geo_type != 'sea' && cell.links.some(function (c) {\n          return c.geo_type == 'sea';\n        });\n      });\n    }\n  }, {\n    key: \"generate_rocks_by_height\",\n    value: function generate_rocks_by_height() {\n      var _this2 = this;\n\n      var max_height = _util2.default.find_min_and_max(this.rrt.nodes, function (e) {\n        return e.height;\n      }).max;\n      this.rock_from_height = Math.ceil(this.rock_height_ratio * max_height);\n      this.diagram.cells.forEach(function (cell) {\n        if (cell.height >= _this2.rock_from_height) {\n          cell.geo_type = 'rock';\n        }\n      });\n    }\n  }, {\n    key: \"generate_rivers\",\n    value: function generate_rivers() {\n      _rivers_and_lakes_generator2.default.generate_by_edges(this.diagram);\n    }\n  }, {\n    key: \"calc_fertility\",\n    value: function calc_fertility() {\n      var square_sum = 0;\n      this.diagram.cells.forEach(function (cell) {\n        return square_sum += _util2.default.convex_polygon_square(cell.nodes);\n      });\n      var fertility_multiplier = Math.round(square_sum / this.diagram.cells.length);\n\n      this.diagram.cells.forEach(function (cell) {\n        if (cell.geo_type == 'sea') {\n          cell.fertility = 0;\n          return;\n        }\n        var sum_rivers_strength = 0;\n        var square = _util2.default.convex_polygon_square(cell.nodes);\n        cell.nodes.forEach(function (node) {\n          return sum_rivers_strength += node.river ? node.river.strength : 0;\n        });\n        cell.fertility = Math.ceil(fertility_multiplier * sum_rivers_strength / square);\n      });\n    }\n  }, {\n    key: \"geo_types_by_fertility\",\n    value: function geo_types_by_fertility() {\n      var stats = [];\n      this.diagram.cells.forEach(function (cell) {\n        return _util2.default.push_uniq(cell.fertility, stats);\n      });\n      stats.sort(function (e1, e2) {\n        return e1 - e2;\n      });\n      var min = stats[0];\n      var max = stats[Math.floor(0.95 * stats.length)]; // 95% persentile cause there's big gaps in the end\n      var geo_type_fertility_thresholds = {\n        bog: _util2.default.normalize_value(0.55, 1, max, 0, min),\n        grass: _util2.default.normalize_value(0.15, 1, max, 0, min),\n        steppe: _util2.default.normalize_value(0.05, 1, max, 0, min),\n        desert: _util2.default.normalize_value(0.0, 1, max, 0, min)\n      };\n\n      this.diagram.cells.forEach(function (cell) {\n        if (cell.geo_type) {\n          return;\n        }\n        for (var i in geo_type_fertility_thresholds) {\n          if (cell.fertility >= geo_type_fertility_thresholds[i]) {\n            cell.geo_type = i;\n            break;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"init_height\",\n    value: function init_height() {\n      this.rrt.nodes.forEach(function (node) {\n        return node.height = 0;\n      });\n    }\n  }, {\n    key: \"generate_heights_by_rrt_branches_length\",\n    value: function generate_heights_by_rrt_branches_length() {\n      var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      var floor_level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      this.rrt.nodes.forEach(function (node) {\n        return node.height += step * node.branch_order + floor_level;\n      });\n    }\n  }, {\n    key: \"height_smooth\",\n    value: function height_smooth() {\n      var max_diff_coef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.3;\n\n      var h = _util2.default.find_min_and_max(this.rrt.nodes, function (node) {\n        return node.height;\n      });\n      var max_diff = max_diff_coef * (h.max - h.min);\n      var changed = 0;\n      do {\n        changed = 0;\n        this.diagram.cells.forEach(function (cell) {\n          var max_height = _util2.default.find_min_and_max(cell.links, function (c) {\n            return c.height;\n          }).max;\n          var height_to_max_diff = max_height - max_diff;\n          if (cell.height < height_to_max_diff) {\n            cell.height = height_to_max_diff;\n            changed++;\n          }\n        });\n        console.log('height smooth cycle cells changed', changed);\n      } while (changed > 0);\n    }\n  }, {\n    key: \"generate_heights_by_rrt_generations\",\n    value: function generate_heights_by_rrt_generations() {\n      var peak_max_height = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;\n      var peak_min_height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n      var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n\n      var peak_height = _util2.default.rand(peak_min_height, peak_max_height);\n      this.rrt.nodes.forEach(function (node) {\n        return node.height += Math.max(node.height, peak_height - step * node.generation);\n      });\n    }\n  }, {\n    key: \"set_nodes_height_by_cell_height\",\n    value: function set_nodes_height_by_cell_height() {\n      this.diagram.nodes.forEach(function (node) {\n        //node.height = Math.round(node.cells.reduce((acc, cell) => cell.height + acc, 0) / node.cells.length);\n        node.height = _util2.default.find_min_and_max(node.cells, function (cell) {\n          return cell.height;\n        }).min;\n      });\n    }\n\n    // for seas and like that\n\n  }, {\n    key: \"heights_stat\",\n    value: function heights_stat() {\n      var stat = [];\n      this.diagram.cells.forEach(function (cell) {\n        if (!stat[cell.height]) stat[cell.height] = 0;\n        stat[cell.height]++;\n      });\n      //stat.forEach((e, i) => console.log('height', i, e));\n      return stat;\n    }\n  }]);\n\n  return Geo;\n}();\n\nexports.default = Geo;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _voronoi_diagram = require(\"voronoi_diagram\");\n\nvar _voronoi_diagram2 = _interopRequireDefault(_voronoi_diagram);\n\nvar _d = require(\"d3\");\n\nvar d3 = _interopRequireWildcard(_d);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Interaction = function () {\n  function Interaction(game) {\n    var _this = this;\n\n    _classCallCheck(this, Interaction);\n\n    this.game = game;\n    document.getElementById('build_road').onclick = this.build_road_button_handler.bind(this);\n    this.map = this.game.map_drawer.map;\n    this.map.stage.interactive = true;\n\n    document.addEventListener('mousemove', this.map_mouse_move_handler.bind(this), false);\n\n    d3.select('#generate_world').on('click', this.trigger_generate_world.bind(this));\n\n    d3.select('#map').on('click', this.map_click_handler.bind(this));\n\n    // from https://bl.ocks.org/pkerpedjiev/cf791db09ebcabaec0669362f4df1776\n    d3.select('#map').call(d3.zoom().scaleExtent([1, 4]).translateExtent([[0, 0], [this.map.view.width, this.map.view.height]]).on(\"zoom\", this.map_zoom.bind(this)));\n\n    this.road_text_div = document.getElementById(\"road_text\");\n\n    this.ticks = 0; // here?\n    this.fps_div = document.getElementById('fps_counter');\n    this.map.ticker.add(function () {\n      _this.ticks++;\n      if (_this.ticks % 10 == 0) {\n        d3.select('#fps_counter').html(_this.map.ticker.FPS | 0);\n      }\n    });\n    this.update_map_scale();\n\n    this.cell_under_cursor = null;\n    this.state = 'initial';\n  }\n\n  _createClass(Interaction, [{\n    key: \"change_state\",\n    value: function change_state(state) {\n      this.state = state;\n      if (state == 'initial') {\n        d3.select('#road_text').html('');\n        this.road_start_cell = null;\n      } else if (state == 'build_road_choose_start') {\n        d3.select('#road_text').html('click road start cell');\n        this.road_start_cell = null;\n      } else if (state == 'build_road_choose_finish') {\n        d3.select('#road_text').html('click road finish cell');\n      } else if (state == 'build_road') {\n        //this.game.build_road(this.road_start_cell, this.road_finish_cell);\n        console.log('suppose the road is built now');\n        this.change_state('initial');\n      }\n    }\n\n    //\n    //  user actions handlers\n    //\n\n  }, {\n    key: \"build_road_button_handler\",\n    value: function build_road_button_handler(args) {\n      this.change_state('build_road_choose_start');\n    }\n  }, {\n    key: \"map_mouse_move_handler\",\n    value: function map_mouse_move_handler(event) {\n      if (event.target != this.map.view) {\n        this.game.map_drawer.clear_cell_under_cursor();\n        this.cell_under_cursor = null;\n        return false;\n      }\n      var mouse_coords = this.get_mouse_coords(event);\n      // TODO check if its fast enought\n      var cell = this.get_cell_under_cursor(mouse_coords);\n      if (!this.cell_under_cursor || this.cell_under_cursor != cell) {\n        this.game.map_drawer.highlight_cell_under_cursor(cell);\n        this.cell_under_cursor = cell;\n      }\n\n      d3.select('#mouse_pos').html('{x: ' + mouse_coords.x + ', y: ' + mouse_coords.y + '}');\n      var world_pos = this.mouse_coords_to_world_coords(mouse_coords);\n      d3.select('#world_pos').html('{x: ' + world_pos.x + ', y: ' + world_pos.y + '}');\n    }\n  }, {\n    key: \"map_click_handler\",\n    value: function map_click_handler() {\n      var mouse_coords = this.get_mouse_coords(d3.event);\n      var cell = this.get_cell_under_cursor(mouse_coords);\n      if (!cell) {\n        console.log('dunno why, but no cell under cursor');\n        return false;\n      }\n      console.log('mouse click cell under cursor', cell);\n      if (this.state == 'build_road_choose_start') {\n        this.road_start_cell = cell;\n        this.change_state('build_road_choose_finish');\n      } else if (this.state == 'click road finish cell') {\n        this.road_finish_cell = cell;\n        this.change_state('build_road');\n      }\n    }\n  }, {\n    key: \"map_zoom\",\n    value: function map_zoom() {\n      this.map.stage.position.x = d3.event.transform.x;\n      this.map.stage.position.y = d3.event.transform.y;\n      this.map.stage.scale.x = d3.event.transform.k;\n      this.map.stage.scale.y = d3.event.transform.k;\n      this.update_map_scale();\n    }\n  }, {\n    key: \"trigger_generate_world\",\n    value: function trigger_generate_world() {\n      console.clear();\n      this.map.stage.children.forEach(function (layer) {\n        return layer.removeChildren();\n      });\n      this.game.generate_map();\n    }\n    ///////////////////////////////////////\n\n\n  }, {\n    key: \"update_map_scale\",\n    value: function update_map_scale() {\n      d3.select('#map_scale').html('{x: ' + this.map.stage.scale.x + ', y: ' + this.map.stage.scale.y + '}');\n    }\n\n    ///////////////////////////////////////  \n    // UTILS\n    ///////////////////////////////////////\n\n  }, {\n    key: \"get_mouse_coords\",\n    value: function get_mouse_coords(event) {\n      return { x: event.offsetX, y: event.offsetY };\n    }\n  }, {\n    key: \"get_cell_under_cursor\",\n    value: function get_cell_under_cursor(mouse_coords) {\n      var world_coords = this.mouse_coords_to_world_coords(mouse_coords);\n      return _voronoi_diagram2.default.find(world_coords, this.game.map_drawer.diagram);\n    }\n  }, {\n    key: \"mouse_coords_to_world_coords\",\n    value: function mouse_coords_to_world_coords(mouse_coords) {\n      var xn = Math.floor((mouse_coords.x - this.map.stage.position.x) / this.map.stage.scale.x),\n          yn = Math.floor((mouse_coords.y - this.map.stage.position.y) / this.map.stage.scale.y);\n      return { x: xn, y: yn };\n    }\n  }]);\n\n  return Interaction;\n}();\n\nexports.default = Interaction;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _rrt_diagram = require(\"rrt_diagram\");\n\nvar _rrt_diagram2 = _interopRequireDefault(_rrt_diagram);\n\nvar _texture_generator = require(\"texture_generator\");\n\nvar _texture_generator2 = _interopRequireDefault(_texture_generator);\n\nvar _balls_generator = require(\"balls_generator\");\n\nvar _balls_generator2 = _interopRequireDefault(_balls_generator);\n\nvar _color = require(\"color\");\n\nvar _color2 = _interopRequireDefault(_color);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MapDrawer = function () {\n  function MapDrawer(width, height) {\n    var _this = this;\n\n    _classCallCheck(this, MapDrawer);\n\n    var PIXI = require('pixi.js');\n    this.map = new PIXI.Application(width, height, {\n      backgroundColor: _color2.default.to_pixi([0, 0, 0]),\n      antialias: true,\n      view: document.getElementById('map')\n    });\n    console.log('renderer', this.map.renderer);\n    document.getElementById('map_container').appendChild(this.map.view);\n    this.layers = {};\n    MapDrawer.layers().forEach(function (layer) {\n      _this.layers[layer] = new PIXI.Container();\n      _this.map.stage.addChild(_this.layers[layer]);\n    });\n  }\n\n  _createClass(MapDrawer, [{\n    key: \"world_init\",\n    value: function world_init(diagram, rrt) {\n      this.diagram = diagram;\n      this.rrt = rrt;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var draw_voronoi_diagram = true;\n      var draw_rrt_links = true;\n      var draw_arrows = false;\n      //let draw_regions = false;\n      //let draw_region_borders = false;\n      var draw_height = false;\n      var draw_rivers = true;\n      var draw_geo_types = true;\n      var water_color = [0, 50, 200];\n      var dark_mode = false; // DEBUG MODE\n\n      this.draw_heights();\n      //this.draw_regions();\n      this.draw_geo_types();\n      this.draw_arrows();\n      this.draw_rrt();\n      //this.draw_region_borders();\n      this.draw_rivers(water_color);\n      // temp\n      var rg = new PIXI.Graphics();\n      this.layers['water'].addChild(rg);\n      this.diagram.cells.forEach(function (cell) {\n        if (cell.geo_type == 'lake') {\n          MapDrawer.draw_smoothed_polygon(rg, cell.nodes, cell, water_color);\n        }\n      });\n      this.dark_mode();\n\n      this.layers['heights'].visible = draw_height;\n      //this.layers['regions'].visible = draw_regions;\n      this.layers['geo'].visible = draw_geo_types;\n      this.layers['arrows'].visible = draw_arrows;\n      this.layers['rrt_links'].visible = draw_rrt_links;\n      //this.layers['borders'].visible = draw_region_borders;\n      this.layers['water'].visible = draw_rivers;\n      if (!draw_voronoi_diagram) {\n        this.layers['regions'].visible = false;\n        this.layers['geo'].visible = false;\n        this.layers['heights'].visible = false;\n      }\n      this.layers['dim_cells'].visible = dark_mode;\n      this.layers['dim'].visible = dark_mode;\n\n      // draw exp path\n      /*\n      let test_from = MapDrawer.draw_polygon(this.path[0].nodes, [50 , 0, 0]);\n      this.layers['roads'].addChild(test_from);\n      let test_to = MapDrawer.draw_polygon(Util.last(this.path).nodes, [50, 50, 0]);\n      this.layers['roads'].addChild(test_to);\n      let road_g = new PIXI.Graphics();\n      this.layers['roads'].addChild(road_g);\n      for (let i = 1; i < this.path.length; i++) {\n        let from = this.path[i-1], to = this.path[i];\n        MapDrawer.draw_broken_line_between_two_cells(from, to, road_g, diagram, [50, 50, 0], 3);\n      }*/\n    }\n  }, {\n    key: \"clear_cell_under_cursor\",\n    value: function clear_cell_under_cursor() {\n      this.layers['under_cursor'].removeChildren();\n    }\n  }, {\n    key: \"highlight_cell_under_cursor\",\n    value: function highlight_cell_under_cursor(cell) {\n      this.clear_cell_under_cursor();\n      var polygon = cell.nodes.map(function (node) {\n        return new PIXI.Point(node.x, node.y);\n      });\n      var border_graphics = new PIXI.Graphics();\n      border_graphics.alpha = 0.75;\n      border_graphics.lineStyle(3, _color2.default.to_pixi([218, 165, 32]));\n      border_graphics.drawPolygon(polygon);\n      border_graphics.closePath(); // strange, but it needed here. some edges are thin without it\n      var inner_graphics = new PIXI.Graphics();\n      inner_graphics.alpha = 0.35;\n      inner_graphics.beginFill(_color2.default.to_pixi([255, 255, 255]));\n      inner_graphics.drawPolygon(polygon);\n      inner_graphics.closePath(); // strange, but it needed here. some edges are thin without it\n      inner_graphics.endFill();\n\n      this.layers['under_cursor'].addChild(border_graphics);\n      this.layers['under_cursor'].addChild(inner_graphics);\n    }\n  }, {\n    key: \"draw_rivers\",\n    value: function draw_rivers(water_color) {\n      var draw_arrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var graphics = new PIXI.Graphics();\n      var graphics_arrows = new PIXI.Graphics();\n      graphics_arrows.alpha = 0.5;\n      this.diagram.nodes.forEach(function (node) {\n        if (!node.river) return;\n        if (node.river.strength === 0) {\n          //let dry_river_color = [121, 96, 76];\n          var dry_river_color = [87, 65, 47];\n          graphics.lineStyle(2, _color2.default.to_pixi(dry_river_color));\n        } else {\n          graphics.lineStyle(MapDrawer.get_line_width_for_river(node.river.strength), _color2.default.to_pixi(water_color));\n        }\n        node.river.children.forEach(function (child) {\n          graphics.moveTo(node.x, node.y);\n          graphics.lineTo(child.x, child.y);\n          graphics.closePath();\n          MapDrawer.draw_arrow(node, child, graphics_arrows, 1, [200, 100, 0]);\n        });\n      });\n      this.layers['water'].addChild(graphics);\n      if (draw_arrows) this.layers['water'].addChild(graphics_arrows);\n    }\n  }, {\n    key: \"highlight_bad_river_links\",\n    value: function highlight_bad_river_links() {\n      var graphics = new PIXI.Graphics();\n      graphics.alpha = 0.5;\n      this.diagram.nodes.forEach(function (node) {\n        if (!node.river) return;\n        node.river.children.forEach(function (child) {\n          if (child.height > node.height) {\n            console.log('river flows up', child.height, node.height);\n            graphics.lineStyle(MapDrawer.get_line_width_for_river(node.river.strength), _color2.default.to_pixi([200, 50, 0]));\n            graphics.moveTo(node.x, node.y);\n            graphics.lineTo(child.x, child.y);\n            graphics.closePath();\n          }\n        });\n      });\n\n      this.layers['water'].addChild(graphics);\n    }\n  }, {\n    key: \"highlight_local_minimums\",\n    value: function highlight_local_minimums() {\n      var _this2 = this;\n\n      this.diagram.cells.forEach(function (cell) {\n        if (cell.geo_type == 'sea') return;\n        if (cell.links.every(function (link) {\n          return link.height > cell.height;\n        })) {\n          var graphics = MapDrawer.draw_polygon(cell.nodes, [255, 0, 125]);\n          graphics.alpha = 0.5;\n          _this2.layers['errors'].addChild(graphics);\n          console.log('inland local minimum', cell.x, cell.y);\n        }\n      });\n    }\n  }, {\n    key: \"print_text_for_each_cell\",\n    value: function print_text_for_each_cell(fn) {\n      var _this3 = this;\n\n      this.diagram.cells.forEach(function (cell) {\n        var msg = fn(cell);\n        var text = new PIXI.Text(msg, { fontFamily: 'Arial', fontSize: 10, fill: 0xff1010 });\n        text.x = cell.x + 2;\n        text.y = cell.y;\n        _this3.layers['errors'].addChild(text);\n      });\n    }\n  }, {\n    key: \"highlight_bad_voronoi_nodes\",\n    value: function highlight_bad_voronoi_nodes() {\n      var _this4 = this;\n\n      this.diagram.nodes.forEach(function (node) {\n        if (node.links.length > 3) {\n          var graphics = new PIXI.Graphics();\n          graphics.lineStyle(2, _color2.default.to_pixi([200, 50, 0]));\n          graphics.drawCircle(node.x, node.y, 3);\n          node.links.forEach(function (e) {\n            graphics.moveTo(node.x, node.y);\n            graphics.lineTo(e.x, e.y);\n            graphics.closePath();\n          });\n          _this4.layers['errors'].addChild(graphics);\n        }\n      });\n    }\n  }, {\n    key: \"highlight_deleted_links\",\n    value: function highlight_deleted_links(deleted_links) {\n      var graphics = new PIXI.Graphics();\n      deleted_links.forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            from = _ref2[0],\n            to = _ref2[1];\n\n        graphics.lineStyle(2, _color2.default.to_pixi([250, 125, 0]));\n        graphics.moveTo(from.x, from.y);\n        graphics.lineTo(to.x, to.y);\n        graphics.closePath();\n      });\n      this.layers['errors'].addChild(graphics);\n    }\n  }, {\n    key: \"draw_heights\",\n    value: function draw_heights() {\n      var _this5 = this;\n\n      var min_height = this.diagram.cells[0].height,\n          max_height = this.diagram.cells[0].height;\n      this.diagram.cells.forEach(function (cell) {\n        if (cell.height < min_height) min_height = cell.height;\n        if (cell.height > max_height) max_height = cell.height;\n      });\n      this.diagram.cells.forEach(function (cell) {\n        var c = _util2.default.normalize_value(cell.height, max_height, 255, min_height, 0);\n        var graphics = MapDrawer.draw_polygon(cell.nodes, [0, c, 0]);\n        _this5.layers['heights'].addChild(graphics); // z-index?\n      });\n    }\n  }, {\n    key: \"draw_regions\",\n    value: function draw_regions() {\n      var _this6 = this;\n\n      this.diagram.cells.forEach(function (cell) {\n        var fill_color = cell.region.color;\n        var graphics = MapDrawer.draw_polygon(cell.nodes, fill_color);\n        _this6.layers['regions'].addChild(graphics);\n      });\n    }\n  }, {\n    key: \"draw_geo_types\",\n    value: function draw_geo_types() {\n      var _this7 = this;\n\n      var geo_types_colors = {\n        sea: [0, 50, 100],\n        rock: [60, 60, 50],\n        //ITS A HACK! its only a background, we draw lake lower with c draw_smoothed_polygon() and blue color\n        lake: [0, 150, 0],\n        bog: [50, 100, 0],\n        grass: [0, 150, 0],\n        steppe: [150, 150, 0],\n        desert: [200, 150, 0]\n      };\n      this.diagram.cells.forEach(function (cell) {\n        if (!geo_types_colors[cell.geo_type]) {\n          throw 'no geo_type color for '.cell.geo_type;\n        }\n        var fill_color = geo_types_colors[cell.geo_type];\n        var graphics = MapDrawer.draw_polygon(cell.nodes, fill_color);\n        _this7.layers['geo'].addChild(graphics);\n      });\n\n      //let balls_generator = new BallsGenerator(this.diagram, geo_types_colors, this);\n      //balls_generator.generate();\n      // DEBUG works EXTREMELY SLOW\n      /*\n      let geo_sprite = new PIXI.Sprite();\n      let texture_generator = new TextureGenerator();\n      let geo_types_textures = {\n        sea: texture_generator.simple([0, 50, 100]),\n        rock: texture_generator.simple([60, 60, 50]),\n        //ITS A HACK! its only a background, we draw lake lower with c draw_smoothed_polygon() and blue color\n        lake: texture_generator.simple([0, 150, 0]),\n        bog: texture_generator.simple([50, 100, 0]),\n        grass: texture_generator.simple([0, 150, 0]),\n        steppe: texture_generator.simple([150, 150, 0]),\n        desert: texture_generator.simple([200, 150, 0]),\n      };\n      \n      this.diagram.cells.forEach(cell => {\n        if (!geo_types_textures[cell.geo_type]) {\n          throw('no geo_type color for '.cell.geo_type);\n        }\n        let graphics = new PIXI.Graphics();\n        graphics.beginFill(0);\n        graphics.drawPolygon(cell.nodes.map(node => new PIXI.Point(node.x, node.y)));\n        graphics.endFill();\n        let sprite = new PIXI.extras.TilingSprite(geo_types_textures[cell.geo_type], this.map.view.width, this.map.view.height);\n        sprite.mask = graphics;\n        geo_sprite.addChild(sprite);\n      });\n      //this.layers['geo'].addChild(geo_sprite);\n      */\n    }\n  }, {\n    key: \"draw_arrows\",\n    value: function draw_arrows() {\n      var graphics = new PIXI.Graphics();\n      this.layers['arrows'].addChild(graphics);\n      this.diagram.cells.forEach(function (cell) {\n        return MapDrawer.draw_arrow(cell, cell.closest_link, graphics, 3, [50, 50, 0]);\n      });\n    }\n  }, {\n    key: \"draw_rrt\",\n    value: function draw_rrt() {\n      var color = [0, 125, 255].sort(function (e1, e2) {\n        return 0.5 - Math.random();\n      });\n      var graphics = new PIXI.Graphics();\n      this.layers['rrt_links'].addChild(graphics);\n      var bla = _util2.default.find_min_and_max(this.rrt.nodes, function (e) {\n        return e.height;\n      });\n\n      // TODO add diff colors for isolated graphs, use Utildo_while_not_empty() for that\n      this.diagram.cells.forEach(function (cell) {\n        graphics.lineStyle(0, _color2.default.to_pixi([0, 0, 0]));\n        var color_by_height = [_util2.default.normalize_value(cell.height, bla.max, color[0], bla.min, 25), _util2.default.normalize_value(cell.height, bla.max, color[1], bla.min, 25), _util2.default.normalize_value(cell.height, bla.max, color[2], bla.min, 25)];\n        graphics.beginFill(_color2.default.to_pixi(color_by_height));\n        graphics.drawCircle(cell.x, cell.y, 4);\n        graphics.endFill();\n        // all links are drawen twice, but i dont care!\n        cell.rrt_links.forEach(function (link) {\n          graphics.lineStyle(3, _color2.default.to_pixi(color_by_height));\n          graphics.moveTo(cell.x, cell.y);\n          graphics.lineTo(link.x, link.y);\n        });\n      });\n    }\n  }, {\n    key: \"draw_region_borders\",\n    value: function draw_region_borders() {\n      var _this8 = this;\n\n      var bg = new PIXI.Graphics();\n      bg.lineStyle(4, _color2.default.to_pixi([0, 60, 0]));\n      this.diagram.edges.forEach(function (edge) {\n        var left_region = edge.left ? _this8.diagram.cells[edge.left.index].region : null;\n        var right_region = edge.right ? _this8.diagram.cells[edge.right.index].region : null;\n        if (left_region != right_region) {\n          bg.moveTo(edge.from.x, edge.from.y);\n          bg.lineTo(edge.to.x, edge.to.y);\n          bg.closePath();\n        }\n      });\n      this.layers['borders'].addChild(bg);\n    }\n  }, {\n    key: \"dark_mode\",\n    value: function dark_mode() {\n      var _this9 = this;\n\n      this.diagram.cells.forEach(function (cell) {\n        var color = cell.geo_type == 'sea' || cell.geo_type == 'lake' ? [0, 0, 100] : [0, 0, 0];\n        var graphics = MapDrawer.draw_polygon(cell.nodes, color);\n        _this9.layers['dim_cells'].addChild(graphics); // z-index?\n      });\n      var g = new PIXI.Graphics();\n      this.layers['dim'].addChild(g);\n      g.alpha = 0.75;\n      g.beginFill = _color2.default.to_pixi([0, 0, 0]);\n      g.drawRect(0, 0, this.map.view.width, this.map.view.height);\n      g.endFill();\n    }\n  }], [{\n    key: \"layers\",\n    value: function layers() {\n      // edges -- test for rivers by edges\n      return [\n      // cells filling\n      'regions', 'geo', 'heights', 'dim_cells',\n      // all items, objects, all that 'upon' the ground\n      'borders', 'water', 'rrt_links', 'arrows', 'edges', 'roads', 'errors',\n      // interaction routines\n      'selection', 'under_cursor',\n      // other\n      'dim'];\n    }\n  }, {\n    key: \"get_line_width_for_river\",\n    value: function get_line_width_for_river(strength) {\n      return 0.5 + Math.log(strength);\n    }\n  }, {\n    key: \"draw_polygon\",\n    value: function draw_polygon(polygon, fill_color) {\n      var graphics = new PIXI.Graphics();\n      graphics.lineStyle(1, _color2.default.to_pixi([0, 30, 0]));\n      graphics.beginFill(_color2.default.to_pixi(fill_color));\n      graphics.drawPolygon(polygon.map(function (node) {\n        return new PIXI.Point(node.x, node.y);\n      }));\n      graphics.closePath(); // strange, but it needed here. some edges are thin without it\n      graphics.endFill();\n      return graphics;\n    }\n\n    // TODO\n\n  }, {\n    key: \"draw_arrow\",\n    value: function draw_arrow(from, to, graphics, line_width, color) {\n      graphics.lineStyle(line_width, _color2.default.to_pixi(color));\n      graphics.moveTo(from.x, from.y);\n      graphics.lineTo(to.x, to.y);\n      graphics.closePath();\n\n      var angle = _util2.default.to_polar_coords(from.x - to.x, from.y - to.y).angle;\n      var p1 = _util2.default.from_polar_coords(angle - _util2.default.radians(15), 7 * line_width);\n      var p2 = _util2.default.from_polar_coords(angle + _util2.default.radians(15), 7 * line_width);\n      graphics.beginFill(_color2.default.to_pixi(color));\n      graphics.moveTo(p1.x + to.x, p1.y + to.y);\n      graphics.lineTo(to.x, to.y);\n      graphics.lineTo(p2.x + to.x, p2.y + to.y);\n      graphics.closePath();\n      graphics.endFill();\n    }\n  }, {\n    key: \"draw_smoothed_polygon\",\n    value: function draw_smoothed_polygon(graphics, polygon, center, water_color) {\n      polygon = polygon.map(function (node) {\n        return MapDrawer.move_by_vector(node, center, _util2.default.rand_float(0.1, 0.3));\n      });\n      var mid_radius = polygon.reduce(function (sum, e) {\n        return sum + _util2.default.distance(e, center);\n      }, 0) / polygon.length;\n      polygon = polygon.filter(function (node, i) {\n        var next_i = i + 1 == polygon.length ? 0 : i + 1;\n        var next_node = polygon[next_i];\n        return _util2.default.distance(node, next_node) >= 0.2 * mid_radius;\n      });\n\n      graphics.beginFill(_color2.default.to_pixi(water_color));\n      var fl_mid = { x: (polygon[0].x + _util2.default.last(polygon).x) / 2, y: (polygon[0].y + _util2.default.last(polygon).y) / 2 };\n      graphics.moveTo(fl_mid.x, fl_mid.y);\n      _util2.default.for_all_consecutive_pairs(polygon, function (cur, next) {\n        var pc_mid = { x: (next.x + cur.x) / 2, y: (next.y + cur.y) / 2 };\n        graphics.quadraticCurveTo(cur.x, cur.y, pc_mid.x, pc_mid.y);\n      });\n      graphics.endFill();\n    }\n  }, {\n    key: \"draw_broken_line_between_two_cells\",\n    value: function draw_broken_line_between_two_cells(c1, c2, graphics, diagram, color) {\n      var width = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n\n      var mid_point = MapDrawer.two_cells_edge_midpoint(diagram, c1, c2);\n      graphics.lineStyle(width, _color2.default.to_pixi(color));\n      graphics.moveTo(c1.x, c1.y);\n      graphics.lineTo(mid_point.x, mid_point.y);\n      graphics.moveTo(mid_point.x, mid_point.y);\n      graphics.lineTo(c2.x, c2.y);\n    }\n  }, {\n    key: \"move_by_vector\",\n    value: function move_by_vector(from, to, length) {\n      var bla = _util2.default.move_by_vector(from.x, from.y, to.x, to.y, length);\n      return { x: bla[0], y: bla[1] };\n    }\n  }, {\n    key: \"two_cells_edge_midpoint\",\n    value: function two_cells_edge_midpoint(diagram, c1, c2) {\n      var my_edge = void 0;\n      for (var i in c2.halfedges) {\n        var edge = diagram.edges[c2.halfedges[i]];\n        if (edge.left == c1 || edge.right == c1) {\n          my_edge = edge;\n          break;\n        }\n      }\n      if (!my_edge) {\n        console.log('two_cells_edge_midpoint not linked cells', c1, c2);\n        throw 'two_cells_edge_midpoint not linked cells';\n      }\n      return { x: (my_edge.from.x + my_edge.to.x) / 2, y: (my_edge.from.y + my_edge.to.y) / 2 };\n    }\n  }, {\n    key: \"color\",\n    value: function color(_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 3),\n          r = _ref4[0],\n          g = _ref4[1],\n          b = _ref4[2];\n\n      return (r << 16) + (g << 8) + b;\n    }\n  }]);\n\n  return MapDrawer;\n}();\n\nexports.default = MapDrawer;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RegionsGatherer = function () {\n  function RegionsGatherer() {\n    _classCallCheck(this, RegionsGatherer);\n  }\n\n  _createClass(RegionsGatherer, null, [{\n    key: 'gather_regions',\n    value: function gather_regions(diagram) {\n      var regions_mode = 'rrt_leafs'; // 'closest'\n      var regions_min_cells = 5;\n      //const regions_opt_cells = 15; // kinda optimum, not max\n\n      // gather regions\n      diagram.regions = [];\n      if (regions_mode == 'rrt_leafs') {\n        var starters = diagram.cells.filter(function (cell) {\n          return cell.rrt_links.length != 2;\n        });\n        starters.forEach(function (cell) {\n          var region = { color: MapDrawer.random_color(), cells: [cell] };\n          diagram.regions.push(region);\n          cell.region = region;\n        });\n        starters.forEach(function (cell) {\n          return RegionsGatherer.gather_all_parents_to_my_region(cell);\n        });\n        RegionsGatherer.recursively_merge_small_regions(diagram);\n        diagram.regions.forEach(function (region, i) {\n          return region.index = i;\n        });\n      } else {\n        var get_linked_cells_func = void 0;\n        if (regions_mode == 'closest') {\n          get_linked_cells_func = function get_linked_cells_func(cell) {\n            return cell.closest_backlinks.concat([cell.closest_link]);\n          };\n        } else if (regions_mode == 'rrt') {\n          get_linked_cells_func = function get_linked_cells_func(cell) {\n            return cell.rrt_links;\n          };\n        } else if (regions_mode == 'rrt_generations') {\n          var generations_per_regions = 5;\n          get_linked_cells_func = function get_linked_cells_func(cell) {\n            var my_region_index = Math.floor(cell.generation / generations_per_regions);\n            return cell.rrt_links.filter(function (link) {\n              return Math.floor(link.generation / generations_per_regions) == my_region_index;\n            });\n          };\n        } else {\n          throw \"unknown regions_mode: \" + regions_mode;\n        }\n        diagram.cells.forEach(function (cell) {\n          return RegionsGatherer.diagram_collect_regions(diagram, cell, get_linked_cells_func);\n        });\n      }\n\n      // after set cells on_border prop\n      diagram.regions.forEach(function (region) {\n        region.on_border = false;\n        for (var i = 0; i < region.cells.length; i++) {\n          if (region.cells[i].on_border) {\n            region.on_border = true;\n            break;\n          }\n        }\n      });\n    }\n  }, {\n    key: 'diagram_collect_regions',\n    value: function (_diagram_collect_regions) {\n      function diagram_collect_regions(_x, _x2, _x3) {\n        return _diagram_collect_regions.apply(this, arguments);\n      }\n\n      diagram_collect_regions.toString = function () {\n        return _diagram_collect_regions.toString();\n      };\n\n      return diagram_collect_regions;\n    }(function (diagram, cell, get_linked_cells_func) {\n      if (cell.region) {\n        return;\n      }\n      var linked_cells = get_linked_cells_func(cell); // cell.closest_backlinks.concat([cell.closest_link]);\n      var region = void 0;\n      for (var i = 0; i < linked_cells.length; i++) {\n        if (linked_cells[i].region) {\n          region = linked_cells[i].region;\n          break;\n        }\n      }\n      if (!region) {\n        region = { color: MapDrawer.random_color(), index: diagram.regions.length, cells: [] };\n        diagram.regions.push(region);\n      }\n      cell.region = region; // index?\n      region.cells.push(cell); // wont be dublicates???\n\n      linked_cells.forEach(function (link) {\n        return diagram_collect_regions(diagram, cell, get_linked_cells_func);\n      });\n    })\n  }, {\n    key: 'gather_all_parents_to_my_region',\n    value: function gather_all_parents_to_my_region(cell) {\n      var parent = RRTDiagram.get_parent(cell);\n      if (!parent || parent.region) {\n        return;\n      }\n      parent.region = cell.region;\n      cell.region.cells.push(parent);\n      return RegionsGatherer.gather_all_parents_to_my_region(parent);\n    }\n  }, {\n    key: 'rrt_leafs_move_all_cells_from_region_to_another_and_delete_it',\n    value: function rrt_leafs_move_all_cells_from_region_to_another_and_delete_it(from, to, diagram) {\n      from.cells.forEach(function (cell) {\n        cell.region = to;\n        to.cells.push(cell);\n      });\n      from.cells.splice(0, from.cells.length);\n      _util2.default.remove_element(from, diagram.regions);\n    }\n  }, {\n    key: 'recursively_merge_small_regions',\n    value: function recursively_merge_small_regions(diagram) {\n      var small_regions = diagram.regions.filter(function (region) {\n        return region.cells.length < regions_min_cells;\n      });\n      if (!small_regions.length) {\n        return;\n      }\n      // smallest first. actually, we need only first one\n      var region = RegionsGatherer.sort_regions_by_size(small_regions)[0]; //small_regions.shift();\n      var linked_regions = RegionsGatherer.gather_all_linked_regions(region);\n      RegionsGatherer.sort_regions_by_size(linked_regions);\n      var target_region = linked_regions[0];\n      /*if (target_region.cells.length > regions_opt_cells) {\n        console.log('too bad merge with big one, size '+region.cells.length+' with size '+target_region.cells.length);\n      }*/\n      RegionsGatherer.rrt_leafs_move_all_cells_from_region_to_another_and_delete_it(region, target_region, diagram);\n      RegionsGatherer.recursively_merge_small_regions(diagram);\n    }\n  }, {\n    key: 'gather_all_linked_regions',\n    value: function gather_all_linked_regions(region) {\n      var linked_regions = [];\n      region.cells.forEach(function (cell) {\n        cell.rrt_links.forEach(function (link) {\n          if (link.region && link.region != region) _util2.default.push_uniq(link.region, linked_regions);\n        });\n      });\n      return linked_regions;\n    }\n  }, {\n    key: 'sort_regions_by_size',\n    value: function sort_regions_by_size(regions) {\n      return regions.sort(function (e1, e2) {\n        return e1.cells.length - e2.cells.length;\n      });\n    }\n  }]);\n\n  return RegionsGatherer;\n}();\n\nexports.default = RegionsGatherer;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _rrt_diagram = require(\"rrt_diagram\");\n\nvar _rrt_diagram2 = _interopRequireDefault(_rrt_diagram);\n\nvar _map_drawer = require(\"map_drawer\");\n\nvar _map_drawer2 = _interopRequireDefault(_map_drawer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  generates rivers on graph\n */\nvar RiversAndLakesGenerator = function () {\n  function RiversAndLakesGenerator() {\n    _classCallCheck(this, RiversAndLakesGenerator);\n  }\n\n  _createClass(RiversAndLakesGenerator, null, [{\n    key: \"generate_by_edges\",\n    value: function generate_by_edges(diagram) {\n      var dry_factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n\n      // only edges between non-linked rrt nodes\n      var edges = diagram.edges.filter(function (edge) {\n        if (!edge.right) return false;\n        var rrt_linked = _rrt_diagram2.default.check_linked(edge.right, edge.left);\n        var sea_side = edge.right.geo_type == 'sea' || edge.left.geo_type == 'sea';\n        return !rrt_linked && !sea_side;\n      });\n      // gather river nodes and links between them\n      var nodes = [],\n          river_roots = [],\n          river_ends = [];\n      // here we only gather links between nodes, nothing more\n      edges.forEach(function (edge) {\n        _util2.default.for_all_consecutive_pairs([edge.from, edge.to], function (node, link) {\n          _util2.default.push_uniq(node, nodes);\n          if (!node.river_links) node.river_links = [];\n          _util2.default.push_uniq(link, node.river_links);\n        });\n      });\n      // here we create rivers from river root nodes, add them to closed list, all others go to open list\n      nodes.forEach(function (node) {\n        node.river = {\n          strength: 0,\n          parents: [],\n          children: []\n        };\n        if (node.on_border) {\n          river_ends.push(node);\n        } else if (node.cells.some(function (cell) {\n          return cell.geo_type == 'sea';\n        })) {\n          river_ends.push(node);\n        } else if (node.river_links.length == 1) {\n          node.river.strength = Math.random() > dry_factor ? _util2.default.rand(1, 10) : 0, river_roots.push(node);\n        } else {}\n      });\n\n      river_ends.forEach(function (node) {\n        RiversAndLakesGenerator.recursively_walk_from_ends(node, null);\n      });\n\n      river_roots.forEach(function (node) {\n        return RiversAndLakesGenerator.recursively_add_strength(node, node.river.strength);\n      });\n\n      // here we only delete temporary river_links prop!\n      nodes.forEach(function (node) {\n        return delete node.river_links;\n      });\n\n      return true;\n    }\n  }, {\n    key: \"recursively_walk_from_ends\",\n    value: function recursively_walk_from_ends(node, from) {\n      if (from) {\n        _util2.default.remove_element(node, from.river.children);\n        from.river.parents.push(node);\n        _util2.default.remove_element(from, node.river.parents);\n        node.river.children.push(from);\n      }\n      var all_but_from = node.river_links.filter(function (l) {\n        return l != from;\n      });\n      if (all_but_from.length > 1 && all_but_from.every(function (link) {\n        return link.river.children.length;\n      })) {\n        return;\n      }\n      all_but_from.forEach(function (link) {\n        RiversAndLakesGenerator.recursively_walk_from_ends(link, node);\n      });\n    }\n  }, {\n    key: \"recursively_add_strength\",\n    value: function recursively_add_strength(node, strength) {\n      node.river.children.forEach(function (child) {\n        child.river.strength += strength;\n        RiversAndLakesGenerator.recursively_add_strength(child, strength);\n      });\n    }\n  }]);\n\n  return RiversAndLakesGenerator;\n}();\n\nexports.default = RiversAndLakesGenerator;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RRTNode = function RRTNode(x, y) {\n  _classCallCheck(this, RRTNode);\n\n  this.x = x;\n  this.y = y;\n  this.rrt_links = [];\n  this.generation = null;\n  this.branch_order = null;\n};\n\nvar RRTDiagram = function () {\n  function RRTDiagram(x_size, y_size) {\n    _classCallCheck(this, RRTDiagram);\n\n    this.nodes = [];\n    this.x_size = x_size;\n    this.y_size = y_size;\n  }\n\n  _createClass(RRTDiagram, [{\n    key: 'get_generation',\n    value: function get_generation(generation) {\n      return this.nodes.filter(function (node) {\n        return node.generation == generation;\n      });\n    }\n  }, {\n    key: 'generations_count',\n    value: function generations_count() {\n      return _util2.default.find_min_and_max(this.nodes, function (node) {\n        return node.generation;\n      }).max;\n    }\n  }, {\n    key: 'generate',\n\n\n    // TODO\n    value: function generate(epsilon) {\n      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n      var reject_limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;\n\n      this.epsilon = epsilon; // for rrt_links rebuild\n      this.nodes.push(new RRTNode(_util2.default.rand(1, this.x_size - 1), _util2.default.rand(1, this.y_size - 1)));\n      if (count < 0) {\n        throw 'bad number of nodes given: ' + count;\n      }\n      var reject_counter = 0;\n\n      while (count && reject_counter < reject_limit) {\n        var random = { x: _util2.default.rand(1, this.x_size - 1), y: _util2.default.rand(1, this.y_size - 1) },\n            nearest = RRTDiagram.find_nearest_node(random, this.nodes),\n\n        // we calc distance second time, but i dont care...\n        distance = RRTDiagram.distance(random, nearest);\n        // distance === 0 -- if we choosed existing point\n        if (distance < epsilon * epsilon || distance === 0) {\n          reject_counter++;\n          continue;\n        }\n        var theta = Math.atan2(random.y - nearest.y, random.x - nearest.x);\n        var node = new RRTNode(Math.round(nearest.x + epsilon * Math.cos(theta)), Math.round(nearest.y + epsilon * Math.sin(theta)));\n        this.nodes.push(node);\n        RRTDiagram.link_two_nodes(node, nearest);\n        reject_counter = 0;\n        count--;\n      }\n      this.calc_branches_length_and_generations();\n    }\n\n    // TODO move it to Util?\n\n  }, {\n    key: 'remove_some_links_and_recalc_all',\n    value: function remove_some_links_and_recalc_all(count, min, max) {\n      var nodes_to_process = this.nodes.filter(function (node) {\n        return node.branch_order >= min && node.branch_order <= max;\n      });\n      if (nodes_to_process.length < count) {\n        throw 'cant remove_some_links_and_recalc_all() count ' + count + ' cause only ' + nodes_to_process.length + ' sutable nodes';\n      }\n      nodes_to_process.sort(function () {\n        return .5 - Math.random();\n      });\n      var deleted_links = [];\n      for (var i = 0; i < count; i++) {\n        var from = nodes_to_process[i];\n        var to = from.rrt_links.find(function (link) {\n          return link.branch_order >= min - 1 && link.branch_order <= max + 1;\n        });\n        if (!to) {\n          throw 'strange, not found sutable link';\n        }\n        RRTDiagram.delink_two_nodes(from, to);\n        deleted_links.push([from, to]);\n      }\n      this.calc_branches_length_and_generations();\n      return deleted_links;\n    }\n  }, {\n    key: 'restore_removed_links',\n    value: function restore_removed_links(deleted_links) {\n      deleted_links.forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            from = _ref2[0],\n            to = _ref2[1];\n\n        return RRTDiagram.link_two_nodes(from, to);\n      });\n      this.calc_branches_length_and_generations();\n    }\n  }, {\n    key: 'calc_branches_length_and_generations',\n    value: function calc_branches_length_and_generations() {\n      var _this = this;\n\n      // reset all prev values\n      this.nodes.forEach(function (node) {\n        node.generation = null;\n        node.branch_order = null;\n        node.longest_branch = null;\n      });\n\n      this.nodes.forEach(function (node) {\n        node.branch_length = 0;\n        _this.recursively_set_branch_length(node);\n        node.longest_branch = _util2.default.find_min_and_max(_this.nodes, function (e) {\n          return e.branch_length;\n        }).max;\n        _this.nodes.forEach(function (e) {\n          return delete e.branch_length;\n        });\n      });\n\n      // we choose local minimum nodes (by longest_branch) and they would be our diagram's \"centers\"\n      var centers = [];\n      this.nodes.forEach(function (node) {\n        var local_minimum = node.rrt_links.every(function (link) {\n          return link.longest_branch >= node.longest_branch;\n        });\n        var no_center_nearby = node.rrt_links.every(function (link) {\n          return centers.indexOf(link) == -1;\n        });\n        if (local_minimum && no_center_nearby) centers.push(node);\n      });\n      // and write path length from it to each node\n      this.nodes.forEach(function (node) {\n        return node.generation = null;\n      });\n      centers.forEach(function (center) {\n        center.generation = 0;\n        _this.recursively_set_generation(center);\n      });\n      // calc branch_order ONLY after calc generations\n      // FIXME sometimes diff between center and some near node is 2\n      var leaf_nodes = this.nodes.filter(function (node) {\n        return node.rrt_links.length == 1;\n      });\n      leaf_nodes.forEach(function (node) {\n        node.branch_order = 0;\n        _this.recursively_calc_branch_order(node);\n      });\n    }\n  }, {\n    key: 'recursively_set_generation',\n    value: function recursively_set_generation(node) {\n      var _this2 = this;\n\n      var filtered = node.rrt_links.filter(function (link) {\n        return link.generation == null;\n      });\n      // we set link.generation and add them to closed list\n      filtered.forEach(function (link) {\n        return link.generation = node.generation + 1;\n      });\n      // and AFTER we call recursively_set_generation on it!\n      filtered.forEach(function (link) {\n        return _this2.recursively_set_generation(link);\n      });\n    }\n\n    // TODO too bad its absolutely like recursively_set_generation()\n\n  }, {\n    key: 'recursively_set_branch_length',\n    value: function recursively_set_branch_length(node) {\n      var _this3 = this;\n\n      var filtered = node.rrt_links.filter(function (link) {\n        return link.branch_length == null;\n      });\n      filtered.forEach(function (link) {\n        return link.branch_length = node.branch_length + 1;\n      });\n      filtered.forEach(function (link) {\n        return _this3.recursively_set_branch_length(link);\n      });\n    }\n  }, {\n    key: 'recursively_calc_branch_order',\n    value: function recursively_calc_branch_order(node) {\n      var _this4 = this;\n\n      // link.generation != 0 -- diagram 'center' nodes work like 'stops'\n      var filtered = node.rrt_links.filter(function (link) {\n        var parent = link.generation < node.generation;\n        var lesser_branch_order = link.branch_order == null || link.branch_order < node.branch_order + 1;\n        return parent && lesser_branch_order;\n      });\n      if (filtered.length > 1) {\n        throw 'seens like several parents';\n      }\n      filtered.forEach(function (link) {\n        return link.branch_order = node.branch_order + 1;\n      });\n      filtered.forEach(function (link) {\n        return _this4.recursively_calc_branch_order(link);\n      });\n    }\n  }], [{\n    key: 'check_linked',\n    value: function check_linked(n1, n2) {\n      return n1.rrt_links.indexOf(n2) != -1;\n    }\n  }, {\n    key: 'find_nearest_node',\n    value: function find_nearest_node(target, nodes) {\n      if (!nodes[0]) {\n        throw 'no nodes';\n      }\n      var nearest = nodes[0],\n          nearestDistance = RRTDiagram.distance(target, nearest);\n      for (var i in nodes) {\n        var d = RRTDiagram.distance(nodes[i], target);\n        if (d < nearestDistance) {\n          nearest = nodes[i];\n          nearestDistance = d;\n        }\n      }\n      return nearest;\n    }\n\n    // PRIVATE\n\n  }, {\n    key: 'link_two_nodes',\n    value: function link_two_nodes(n1, n2) {\n      _util2.default.push_uniq(n1, n2.rrt_links);\n      _util2.default.push_uniq(n2, n1.rrt_links);\n    }\n\n    // PRIVATE\n\n  }, {\n    key: 'delink_two_nodes',\n    value: function delink_two_nodes(n1, n2) {\n      _util2.default.remove_element(n1, n2.rrt_links);\n      _util2.default.remove_element(n2, n1.rrt_links);\n    }\n  }, {\n    key: 'get_parent',\n    value: function get_parent(node) {\n      var ret = node.rrt_links.filter(function (n) {\n        return n.generation < node.generation;\n      });\n      if (!ret.length) return null; // historically it is null\n      if (ret.length != 1) {\n        console.log('more than one parent', node);\n        throw 'more than one parent';\n      }\n      return ret[0];\n    }\n\n    // PRIVATE\n\n  }, {\n    key: 'distance',\n    value: function distance(a, b) {\n      var dx = a.x - b.x,\n          dy = a.y - b.y;\n      return dx * dx + dy * dy;\n    }\n  }]);\n\n  return RRTDiagram;\n}();\n\nexports.default = RRTDiagram;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _map_drawer = require(\"map_drawer\");\n\nvar _map_drawer2 = _interopRequireDefault(_map_drawer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TextureGenerator = function () {\n  function TextureGenerator() {\n    _classCallCheck(this, TextureGenerator);\n  }\n\n  _createClass(TextureGenerator, [{\n    key: \"simple\",\n    value: function simple(base) {\n      var step = 10;\n      var lower = [this.color_channel(base[0], -step), this.color_channel(base[1], -step), this.color_channel(base[2], -step)];\n      var upper = [this.color_channel(base[0], step), this.color_channel(base[1], step), this.color_channel(base[2], step)];\n      return this.generate(lower, upper, step, 400, 2);\n    }\n  }, {\n    key: \"color_channel\",\n    value: function color_channel(base, step) {\n      if (base == 0) {\n        return 0;\n      }\n      var res = base + step;\n      if (res < 0 || res > 255) {\n        throw 'color channel out of border';\n      }\n      return res;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(lower, upper, step, tiles_count, tile_size) {\n      var graphics = new PIXI.Graphics();\n      for (var y = 0; y < tiles_count; y++) {\n        for (var x = 0; x < tiles_count; x++) {\n          graphics.beginFill(_map_drawer2.default.color(this.random_color(lower, upper, step)));\n          graphics.drawRect(tile_size * x, tile_size * y, tile_size, tile_size);\n          graphics.endFill();\n        }\n      }\n      var texture = graphics.generateCanvasTexture(PIXI.SCALE_MODES.NEAREST, 1);\n      return texture;\n    }\n  }, {\n    key: \"random_color\",\n    value: function random_color(lower, upper) {\n      var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      return [this.rand(lower[0], upper[0], step), this.rand(lower[1], upper[1], step), this.rand(lower[2], upper[2], step)];\n    }\n  }, {\n    key: \"rand\",\n    value: function rand(lower, upper) {\n      var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      return step * _util2.default.rand(lower / step | 0, upper / step | 0);\n    }\n  }]);\n\n  return TextureGenerator;\n}();\n\nexports.default = TextureGenerator;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Util = function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, null, [{\n    key: 'exec_in_cycle_with_delay',\n    value: function exec_in_cycle_with_delay(index, limit, delay, func) {\n      var final_func = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};\n\n      if (typeof limit === \"function\" && !limit() || index >= limit) {\n        final_func(index);\n        return;\n      }\n      func(index);\n      setTimeout(function () {\n        Util.exec_in_cycle_with_delay(index + 1, limit, delay, func, final_func);\n      }, delay);\n    }\n  }, {\n    key: 'rand',\n    value: function rand(min, max) {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n  }, {\n    key: 'rand_element',\n    value: function rand_element(arr) {\n      if (arr.length == 0) return false;\n      return arr[Util.rand(0, arr.length - 1)];\n    }\n  }, {\n    key: 'rand_float',\n    value: function rand_float(min, max) {\n      return Math.random() * (max - min) + min;\n    }\n  }, {\n    key: 'normalize_value',\n    value: function normalize_value(value, max, normal_max) {\n      var min = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var normal_min = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n      if (value > max || value < min) {\n        console.log('value out of range', value, max, normal_max, min, normal_min);\n        throw 'value out of range';\n      }\n      return (value - min) * (normal_max - normal_min) / (max - min) + normal_min;\n    }\n\n    ///////////////////////////////////\n    // ARRAYS\n    ///////////////////////////////////\n\n  }, {\n    key: 'last',\n    value: function last(array) {\n      return array.length == 0 ? false : array[array.length - 1];\n    }\n  }, {\n    key: 'push_uniq',\n    value: function push_uniq(element, arr) {\n      if (arr.indexOf(element) == -1) {\n        arr.push(element);\n      }\n    }\n  }, {\n    key: 'merge',\n    value: function merge(arr1, arr2) {\n      arr2.forEach(function (e) {\n        return Util.push_uniq(e, arr1);\n      });\n    }\n  }, {\n    key: 'remove_element',\n    value: function remove_element(element, arr) {\n      var index = arr.indexOf(element);\n      if (index !== -1) {\n        arr.splice(index, 1);\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: 'for_all_consecutive_pairs',\n    value: function for_all_consecutive_pairs(array, fun) {\n      if (array.length < 2) {\n        return false;\n      }\n      for (var i = 0; i < array.length; i++) {\n        var cur = array[i];\n        var next_index = i + 1 == array.length ? 0 : i + 1;\n        var next = array[next_index];\n        fun(cur, next, i, next_index);\n      }\n    }\n  }, {\n    key: 'find_min_and_max',\n    value: function find_min_and_max(array, value_func) {\n      if (!array.length) return false;\n      var ret = { min: null, max: null, min_element: null, max_element: null };\n      array.forEach(function (e) {\n        var res = value_func(e);\n        if (isNaN(res) || res === null) return;\n        if (ret.min == null || ret.max == null) {\n          ret.min = res;\n          ret.max = res;\n          ret.min_element = e;\n          ret.max_element = e;\n          return;\n        }\n        if (res < ret.min) {\n          ret.min = res;\n          ret.min_element = e;\n        }\n        if (res > ret.max) {\n          ret.max = res;\n          ret.max_element = e;\n        }\n      });\n      return ret;\n    }\n\n    // ??? experimental. some standard routine for cyclic open_list processing\n\n  }, {\n    key: 'do_while_not_empty',\n    value: function do_while_not_empty(open_list, func) {\n      var length_before = void 0,\n          step = 0;\n      do {\n        length_before = open_list.length;\n        open_list = open_list.filter(function (element) {\n          return !func(element, step++);\n        });\n        if (length_before == open_list.length) {\n          console.log('do_while_not_empty() open_list length not chenged, bailing out', length_before, open_list);\n          return false;\n        }\n      } while (open_list.length);\n      return true;\n    }\n\n    //////////////////////////////////////////\n    // geometry\n    //////////////////////////////////////////\n\n  }, {\n    key: 'to_polar_coords',\n    value: function to_polar_coords(x, y) {\n      var radius = Math.sqrt(x * x + y * y);\n      var angle = Math.atan2(y, x);\n      return { angle: angle, radius: radius };\n    }\n  }, {\n    key: 'from_polar_coords',\n    value: function from_polar_coords(angle, radius) {\n      var x = radius * Math.cos(angle);\n      var y = radius * Math.sin(angle);\n      return { x: x, y: y };\n    }\n  }, {\n    key: 'radians',\n    value: function radians(degrees) {\n      return degrees * Math.PI / 180;\n    }\n  }, {\n    key: 'degrees',\n    value: function degrees(radians) {\n      return radians * 180 / Math.PI;\n    }\n  }, {\n    key: 'move_by_vector',\n    value: function move_by_vector(xf, yf, xt, yt, length) {\n      // why i wrote j_max + 1? thats for last gradient area -- otherwise it will be just a single dot\n      return [xf + (xt - xf) * length, yf + (yt - yf) * length];\n    }\n  }, {\n    key: 'convex_polygon_centroid',\n    value: function convex_polygon_centroid(points) {\n      var p1 = points[0];\n      var square_sum = 0;\n      var xc = 0,\n          yc = 0;\n      for (var i = 1; i < points.length - 1; i++) {\n        var p2 = points[i];\n        var p3 = points[i + 1];\n        var square = ((p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y)) / 2; // triangle square\n        square_sum += square;\n        xc += square * (p1.x + p2.x + p3.x) / 3;\n        yc += square * (p1.y + p2.y + p3.y) / 3;\n      }\n      return { x: xc / square_sum, y: yc / square_sum };\n    }\n\n    // points should be sorted by angle to center!!!\n\n  }, {\n    key: 'convex_polygon_square',\n    value: function convex_polygon_square(points) {\n      var p1 = points[0];\n      var square = 0;\n      for (var i = 1; i < points.length - 1; i++) {\n        var p2 = points[i];\n        var p3 = points[i + 1];\n        square += Math.abs((p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y)) / 2;\n      }\n      return square;\n    }\n  }, {\n    key: 'distance',\n    value: function distance(p1, p2) {\n      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n    }\n  }]);\n\n  return Util;\n}();\n\nexports.default = Util;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = require(\"util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _d = require(\"d3\");\n\nvar d3 = _interopRequireWildcard(_d);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  we take original voronoi diagram from d3,\n *  add lloyd relaxation\n *  and then reorganize its internal structure, cause its annoying and awful, for my taste\n *  and to each cell we add array of links to neig nodes, sorted by distance\n */\nvar VoronoiDiagram = function () {\n  function VoronoiDiagram() {\n    _classCallCheck(this, VoronoiDiagram);\n  }\n\n  _createClass(VoronoiDiagram, null, [{\n    key: \"generate\",\n    value: function generate(nodes, width, height) {\n      var lloyd_relaxation_steps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      var voronoi = d3.voronoi().x(function (p) {\n        return p.x;\n      }).y(function (p) {\n        return p.y;\n      }).size([width, height]);\n      var original_diagram = voronoi(nodes);\n      for (var i = 0; i < lloyd_relaxation_steps; i++) {\n        original_diagram = VoronoiDiagram.lloyd_relaxation(original_diagram, voronoi);\n      }\n      var diagram = {};\n      // rewrite edges and nodes\n      // the problem with original d3 diagram is not only that node is array(2), but also is that\n      // it has nodes duplicates! we are to \"regather\" all nodes\n      diagram.nodes = [];\n      diagram.edges = original_diagram.edges.map(function (edge) {\n        var node_from = void 0,\n            node_to = void 0;\n        diagram.nodes.forEach(function (node) {\n          if (VoronoiDiagram.seems_like_nodes_are_equal(node, edge[0])) {\n            node_from = node;\n          }\n          if (VoronoiDiagram.seems_like_nodes_are_equal(node, edge[1])) {\n            node_to = node;\n          }\n        });\n        if (!node_from) {\n          node_from = { x: edge[0][0], y: edge[0][1], cells: [], links: [] };\n          diagram.nodes.push(node_from);\n        }\n        if (!node_to) {\n          node_to = { x: edge[1][0], y: edge[1][1], cells: [], links: [] };\n          diagram.nodes.push(node_to);\n        }\n        //node_from.links.push(node_to);\n        _util2.default.push_uniq(node_to, node_from.links);\n        node_to.links.push(node_from);\n        _util2.default.push_uniq(node_from, node_to.links);\n\n        _util2.default.push_uniq(edge.left.data, node_from.cells);\n        _util2.default.push_uniq(edge.left.data, node_to.cells);\n        if (edge.right) {\n          _util2.default.push_uniq(edge.right.data, node_from.cells);\n          _util2.default.push_uniq(edge.right.data, node_to.cells);\n        }\n        return {\n          from: node_from,\n          to: node_to,\n          left: edge.left.data,\n          right: edge.right ? edge.right.data : undefined\n        };\n      });\n      // rewrite cells\n      diagram.cells = original_diagram.cells.map(function (orig_cell) {\n        var cell = orig_cell.site.data; // original object!!! and we change it here!!!\n        cell.nodes = diagram.nodes.filter(function (node) {\n          return node.cells.indexOf(cell) != -1;\n        });\n        cell.nodes.sort(function (n1, n2) {\n          var angle1 = _util2.default.to_polar_coords(n1.x - cell.x, n1.y - cell.y).angle;\n          var angle2 = _util2.default.to_polar_coords(n2.x - cell.x, n2.y - cell.y).angle;\n          return angle1 - angle2;\n        });\n        cell.halfedges = orig_cell.halfedges;\n        cell.index = orig_cell.site.index;\n        // !!! we rewrite origin coordinates that COULD change (after lloyd relaxation)\n        cell.x = orig_cell.site[0];\n        cell.y = orig_cell.site[1];\n        return cell;\n      });\n      diagram.cells.forEach(function (cell) {\n        var links = [];\n        cell.halfedges.forEach(function (halfedge_index) {\n          var halfedge = diagram.edges[halfedge_index];\n          var link_site = halfedge.left == cell ? halfedge.right : halfedge.left;\n          // near-border halfedges dont have right or left cell \n          if (!link_site) {\n            return;\n          }\n          _util2.default.push_uniq(diagram.cells[link_site.index], links);\n        });\n        // links sorted by distance -- from lowest to highest!\n        links.sort(function (e1, e2) {\n          return _util2.default.distance(cell, e1) - _util2.default.distance(cell, e2);\n        });\n        cell.links = links;\n      });\n      diagram.width = width;\n      diagram.height = height;\n\n      // final checks\n      diagram.nodes.forEach(function (node) {\n        /* its normal -- 4 or more nodes lie on circle\n        if (node.links.length > 3) {\n          console.log(\"ITS TOTAL DISASTER\", node.x, node.y);\n          node.links.forEach(e => console.log(\"DISASTER\", e.x, e.y));\n          //throw('ITS TOTAL DISASTER voronoi diagram');\n        }\n        */\n        if (node.links.length < 2) {\n          console.log(\"a little split\", node.x, node.y, node.links);\n          throw 'ITS TOTAL DISASTER voronoi diagram';\n        }\n        /* its normal too\n        if (node.cells.length > 3 || node.cells.length == 0) {\n          console.log(\"BAD cells\", node.x, node.y, node.cells.length);\n          //throw('ITS TOTAL DISASTER voronoi diagram');\n        }\n        */\n      });\n\n      return diagram;\n    }\n\n    // TODO binary tree search\n\n  }, {\n    key: \"find\",\n    value: function find(point, diagram) {\n      return _util2.default.find_min_and_max(diagram.cells, function (e) {\n        return _util2.default.distance(point, e);\n      }).min_element;\n    }\n  }, {\n    key: \"lloyd_relaxation\",\n    value: function lloyd_relaxation(diagram, voronoi) {\n      var to_move = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      var new_points = diagram.polygons().map(function (p) {\n        // well, its not real lloyd relaxation, we move new cell center not to centroid, but move\n        // it by value of 'to_move' to direction to centroid\n        var poly = p.map(function (e) {\n          return { x: e[0], y: e[1] };\n        });\n        var pf = _util2.default.convex_polygon_centroid(poly);\n        var res = _util2.default.move_by_vector(p.data.x, p.data.y, pf.x, pf.y, to_move);\n        return { x: res[0], y: res[1] };\n      });\n      return voronoi(new_points);\n    }\n\n    // PRIVATE. TRY to heal shizophrenia -- different, but very close nodes\n    // but it can lead us to total \n\n  }, {\n    key: \"seems_like_nodes_are_equal\",\n    value: function seems_like_nodes_are_equal(node, old_node) {\n      var very_close_is = 0.0000000000001;\n      return Math.abs(node.x - old_node[0]) < very_close_is && Math.abs(node.y - old_node[1]) < very_close_is;\n      //return node.x == old_node[0] && node.y == old_node[1];\n    }\n  }]);\n\n  return VoronoiDiagram;\n}();\n\nexports.default = VoronoiDiagram;\n"]}